import { pgTable, text, serial, integer, timestamp, boolean, jsonb, primaryKey } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  role: text("role").default("user").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  role: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Tabela de treinadores/professores
export const trainers = pgTable("trainers", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  specialties: text("specialties").array(),
  calendarId: text("calendar_id"), // ID do calendário no Google Calendar
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTrainerSchema = createInsertSchema(trainers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const trainerValidationSchema = insertTrainerSchema.extend({
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  calendarId: z.string().optional(),
  active: z.boolean().optional(),
});

export type InsertTrainer = z.infer<typeof insertTrainerSchema>;
export type Trainer = typeof trainers.$inferSelect;

// Tabela de alunos (expandindo leads com status "Aluno")
export const students = pgTable("students", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id), // Referência ao lead correspondente
  address: text("address"),
  preferences: text("preferences"),
  source: text("source").notNull(), // "Favale" ou "Pink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertStudentSchema = createInsertSchema(students).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const studentValidationSchema = insertStudentSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  address: z.string().optional(),
  preferences: z.string().optional(),
  source: z.string().min(1, "A origem é obrigatória"),
  active: z.boolean().optional(),
});

export type InsertStudent = z.infer<typeof insertStudentSchema>;
export type Student = typeof students.$inferSelect;

// Lead schema
export const leads = pgTable("leads", {
  id: serial("id").primaryKey(),
  entryDate: timestamp("entry_date").defaultNow().notNull(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  state: text("state").notNull(),
  campaign: text("campaign").notNull(),
  tags: text("tags").array().notNull(),
  source: text("source").notNull(), // "Favale" or "Pink"
  status: text("status").notNull(), // "Lead" or "Aluno"
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Criar um schema base para inserção de leads, omitindo campos autoincrementais/autogenerated
export const baseInsertLeadSchema = createInsertSchema(leads).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Schema usado para inserção no banco de dados, aceita Date ou string ISO
export const insertLeadSchema = baseInsertLeadSchema.extend({
  entryDate: z.union([
    z.string(),
    z.date()
  ]).optional(),
});

export const leadValidationSchema = insertLeadSchema.extend({
  entryDate: z.union([
    z.string().transform(val => {
      try {
        // Formatar a data se estiver no padrão DD/MM/YYYY (formato brasileiro)
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(val)) {
          const [day, month, year] = val.split('/');
          return `${year}-${month}-${day}`;
        }
        // Outros formatos
        return val;
      } catch (e) {
        return val;
      }
    }).refine(value => !isNaN(Date.parse(value)), {
      message: "Data de entrada precisa ser uma data válida"
    }),
    z.date()
  ]),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().min(1, "O telefone é obrigatório"),
  state: z.string().min(1, "O estado é obrigatório"),
  campaign: z.string().default("Importação em Lote"),
  source: z.string().min(1, "A origem é obrigatória"),
  status: z.string().min(1, "O status é obrigatório"),
});

export type InsertLead = z.infer<typeof insertLeadSchema>;
export type Lead = typeof leads.$inferSelect;

// Tabela de sessões de treinamento
export const sessions = pgTable("sessions", {
  id: serial("id").primaryKey(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  studentId: integer("student_id").references(() => students.id).notNull(),
  trainerId: integer("trainer_id").references(() => trainers.id).notNull(),
  location: text("location").notNull(), // Endereço do treino
  notes: text("notes"),
  status: text("status").default("agendado").notNull(), // agendado, concluído, cancelado, remarcado
  source: text("source").notNull(), // "Favale" ou "Pink"
  googleEventId: text("google_event_id"), // ID do evento no Google Calendar
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertSessionSchema = createInsertSchema(sessions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const sessionBaseValidationSchema = insertSessionSchema.extend({
  startTime: z.union([
    z.string().refine(value => !isNaN(Date.parse(value)), {
      message: "Horário de início precisa ser uma data válida"
    }),
    z.date()
  ]),
  endTime: z.union([
    z.string().refine(value => !isNaN(Date.parse(value)), {
      message: "Horário de término precisa ser uma data válida"
    }),
    z.date()
  ]),
  studentId: z.number().int().positive("ID do aluno inválido"),
  trainerId: z.number().int().positive("ID do professor inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  notes: z.string().optional(),
  status: z.string().min(1, "O status é obrigatório"),
  source: z.string().min(1, "A origem é obrigatória"),
  googleEventId: z.string().optional(),
});

// Validação adicional para a criação de sessões
export const sessionValidationSchema = sessionBaseValidationSchema.refine(
  data => {
    // Verifica se a data de término é posterior à data de início
    const startTime = new Date(data.startTime instanceof Date ? data.startTime : data.startTime);
    const endTime = new Date(data.endTime instanceof Date ? data.endTime : data.endTime);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = typeof sessions.$inferSelect;

// Tabela de histórico de alterações em sessões
export const sessionHistory = pgTable("session_history", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").references(() => sessions.id).notNull(),
  changedAt: timestamp("changed_at").defaultNow().notNull(),
  changeType: text("change_type").notNull(), // created, updated, cancelled, rescheduled
  userId: integer("user_id").references(() => users.id).notNull(), // Quem fez a alteração
  oldValue: jsonb("old_value"), // Valor anterior (para campos alterados)
  newValue: jsonb("new_value"), // Novo valor
});

export const insertSessionHistorySchema = createInsertSchema(sessionHistory).omit({
  id: true,
});

export type InsertSessionHistory = z.infer<typeof insertSessionHistorySchema>;
export type SessionHistory = typeof sessionHistory.$inferSelect;

// WhatsApp mensagens
export const whatsappMessages = pgTable("whatsapp_messages", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id).notNull(),
  direction: text("direction").notNull(), // "incoming" ou "outgoing"
  content: text("content").notNull(),
  status: text("status").notNull(), // "sent", "delivered", "read", "failed"
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  mediaUrl: text("media_url"), // URL opcional para mídia (imagens, áudio, etc.)
  mediaType: text("media_type"), // Tipo de mídia (image, audio, video, document)
  messageId: text("message_id"), // ID da mensagem na API do WhatsApp
});

export const insertWhatsappMessageSchema = createInsertSchema(whatsappMessages).omit({
  id: true,
});

export const whatsappMessageValidationSchema = insertWhatsappMessageSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  direction: z.enum(["incoming", "outgoing"], {
    errorMap: () => ({ message: "Direção deve ser 'incoming' ou 'outgoing'" })
  }),
  content: z.string().min(1, "O conteúdo da mensagem é obrigatório"),
  status: z.enum(["pending", "sent", "delivered", "read", "failed"], {
    errorMap: () => ({ message: "Status inválido" })
  }),
  mediaUrl: z.string().url("URL de mídia inválida").optional(),
  mediaType: z.enum(["image", "audio", "video", "document"], {
    errorMap: () => ({ message: "Tipo de mídia inválido" })
  }).optional(),
  messageId: z.string().optional(),
});

export type InsertWhatsappMessage = z.infer<typeof insertWhatsappMessageSchema>;
export type WhatsappMessage = typeof whatsappMessages.$inferSelect;

// Tabela de tarefas
export const tasks = pgTable("tasks", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  status: text("status").default("todo").notNull(), // todo, in-progress, review, done
  priority: text("priority").default("medium").notNull(), // low, medium, high
  createdById: integer("created_by_id").references(() => users.id).notNull(), // Admin que criou a tarefa
  assigneeId: integer("assignee_id").references(() => users.id).notNull(), // Usuário responsável
  dueDate: timestamp("due_date"), // Data de vencimento opcional
  tags: text("tags").array(), // Tags para organização
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
  // Campos de relacionamento com entidades do CRM
  relatedLeadId: integer("related_lead_id").references(() => leads.id), // Lead relacionado
  relatedStudentId: integer("related_student_id").references(() => students.id), // Aluno relacionado
  relatedTrainerId: integer("related_trainer_id").references(() => trainers.id), // Treinador relacionado
  relatedSessionId: integer("related_session_id").references(() => sessions.id), // Sessão relacionada
  // Campos para recorrência
  isRecurring: boolean("is_recurring").default(false), // Determina se a tarefa é recorrente
  recurringPattern: text("recurring_pattern"), // daily, weekly, monthly, etc.
  recurringInterval: integer("recurring_interval"), // Intervalo de recorrência (ex: a cada 2 semanas)
  nextRecurrenceDate: timestamp("next_recurrence_date"), // Próxima data de recorrência
});

export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskValidationSchema = insertTaskSchema.extend({
  title: z.string().min(1, "O título é obrigatório"),
  description: z.string().optional(),
  status: z.enum(["todo", "in-progress", "review", "done"], {
    errorMap: () => ({ message: "Status inválido" })
  }),
  priority: z.enum(["low", "medium", "high"], {
    errorMap: () => ({ message: "Prioridade inválida" })
  }),
  createdById: z.number().int().positive("ID do criador inválido"),
  assigneeId: z.number().int().positive("ID do responsável inválido"),
  dueDate: z.union([
    z.string().refine(value => !isNaN(Date.parse(value)), {
      message: "Data de vencimento precisa ser uma data válida"
    }),
    z.date()
  ]).optional(),
  tags: z.array(z.string()).optional(),
  relatedLeadId: z.number().int().positive("ID do lead inválido").optional(),
  relatedStudentId: z.number().int().positive("ID do aluno inválido").optional(),
  relatedTrainerId: z.number().int().positive("ID do treinador inválido").optional(),
  relatedSessionId: z.number().int().positive("ID da sessão inválida").optional(),
  isRecurring: z.boolean().optional(),
  recurringPattern: z.enum(["daily", "weekly", "monthly", "yearly"], {
    errorMap: () => ({ message: "Padrão de recorrência inválido" })
  }).optional(),
  recurringInterval: z.number().int().positive("Intervalo de recorrência inválido").optional(),
  nextRecurrenceDate: z.union([
    z.string().refine(value => !isNaN(Date.parse(value)), {
      message: "Próxima data de recorrência precisa ser uma data válida"
    }),
    z.date()
  ]).optional(),
});

export type InsertTask = z.infer<typeof insertTaskSchema>;
export type Task = typeof tasks.$inferSelect;

// Tabela de observadores de tarefas (permite múltiplos observadores por tarefa)
export const taskWatchers = pgTable("task_watchers", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (t) => ({
  // Constraint para garantir que um usuário não observe a mesma tarefa mais de uma vez
  unq: primaryKey({ columns: [t.taskId, t.userId] }),
}));

export const insertTaskWatcherSchema = createInsertSchema(taskWatchers).omit({
  id: true,
  createdAt: true,
});

export type InsertTaskWatcher = z.infer<typeof insertTaskWatcherSchema>;
export type TaskWatcher = typeof taskWatchers.$inferSelect;

// Tabela de itens de checklist para tarefas
export const taskChecklistItems = pgTable("task_checklist_items", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  content: text("content").notNull(),
  isCompleted: boolean("is_completed").default(false).notNull(),
  completedAt: timestamp("completed_at"),
  completedById: integer("completed_by_id").references(() => users.id),
  position: integer("position").default(0).notNull(), // Para ordenação
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskChecklistItemSchema = createInsertSchema(taskChecklistItems).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export type InsertTaskChecklistItem = z.infer<typeof insertTaskChecklistItemSchema>;
export type TaskChecklistItem = typeof taskChecklistItems.$inferSelect;

// Tabela de comentários em tarefas
export const taskComments = pgTable("task_comments", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertTaskCommentSchema = createInsertSchema(taskComments).omit({
  id: true,
  createdAt: true,
});

export const taskCommentValidationSchema = insertTaskCommentSchema.extend({
  content: z.string().max(500, "Comentário deve ter no máximo 500 caracteres"),
});

export type InsertTaskComment = z.infer<typeof insertTaskCommentSchema>;
export type TaskComment = typeof taskComments.$inferSelect;

// Tabela de histórico de atividades em tarefas
export const taskHistory = pgTable("task_history", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  action: text("action").notNull(), // created, updated, commented, completed, etc.
  details: jsonb("details"), // Detalhes da mudança
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const insertTaskHistorySchema = createInsertSchema(taskHistory).omit({
  id: true,
  createdAt: true,
});

export type InsertTaskHistory = z.infer<typeof insertTaskHistorySchema>;
export type TaskHistory = typeof taskHistory.$inferSelect;
