import { pgTable, text, serial, integer, timestamp, boolean, jsonb } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  role: text("role").default("user").notNull(),
});

export const insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true,
  role: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

// Tabela de treinadores/professores
export const trainers = pgTable("trainers", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  specialties: text("specialties").array(),
  source: text("source").notNull(), // "Favale", "Pink", ou "FavalePink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTrainerSchema = createInsertSchema(trainers).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const trainerValidationSchema = insertTrainerSchema.extend({
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().optional(),
  specialties: z.array(z.string()).optional(),
  source: z.enum(["Favale", "Pink", "FavalePink"], {
    errorMap: () => ({ message: "Origem deve ser 'Favale', 'Pink' ou 'FavalePink'" })
  }),
  active: z.boolean().optional(),
});

export type InsertTrainer = z.infer<typeof insertTrainerSchema>;
export type Trainer = typeof trainers.$inferSelect;

// Tabela de alunos (expandindo leads com status "Aluno")
export const students = pgTable("students", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id), // Referência ao lead correspondente
  address: text("address"),
  preferences: text("preferences"),
  source: text("source").notNull(), // "Favale" ou "Pink"
  active: boolean("active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertStudentSchema = createInsertSchema(students).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const studentValidationSchema = insertStudentSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  address: z.string().optional(),
  preferences: z.string().optional(),
  source: z.string().min(1, "A origem é obrigatória"),
  active: z.boolean().optional(),
});

export type InsertStudent = z.infer<typeof insertStudentSchema>;
export type Student = typeof students.$inferSelect;

// Lead schema
export const leads = pgTable("leads", {
  id: serial("id").primaryKey(),
  entryDate: timestamp("entry_date").defaultNow().notNull(),
  name: text("name").notNull(),
  email: text("email").notNull(),
  phone: text("phone").notNull(),
  state: text("state").notNull(),
  campaign: text("campaign").notNull(),
  tags: text("tags").array().notNull(),
  source: text("source").notNull(), // "Favale" or "Pink"
  status: text("status").notNull(), // "Lead" or "Aluno"
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Criar um schema base para inserção de leads, omitindo campos autoincrementais/autogenerated
export const baseInsertLeadSchema = createInsertSchema(leads).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Schema usado para inserção no banco de dados, aceita Date ou string ISO
export const insertLeadSchema = baseInsertLeadSchema.extend({
  entryDate: z.union([
    z.string(),
    z.date()
  ]).optional(),
});

export const leadValidationSchema = insertLeadSchema.extend({
  entryDate: z.union([
    z.string().transform(val => {
      try {
        // Formatar a data se estiver no padrão DD/MM/YYYY (formato brasileiro)
        if (/^\d{2}\/\d{2}\/\d{4}$/.test(val)) {
          const [day, month, year] = val.split('/');
          return `${year}-${month}-${day}`;
        }
        // Outros formatos
        return val;
      } catch (e) {
        return val;
      }
    }).refine(value => !isNaN(Date.parse(value)), {
      message: "Data de entrada precisa ser uma data válida"
    }),
    z.date()
  ]),
  name: z.string().min(1, "O nome é obrigatório"),
  email: z.string().min(1, "O e-mail é obrigatório").email("E-mail inválido"),
  phone: z.string().min(1, "O telefone é obrigatório"),
  state: z.string().min(1, "O estado é obrigatório"),
  campaign: z.string().default("Importação em Lote"),
  source: z.string().min(1, "A origem é obrigatória"),
  status: z.string().min(1, "O status é obrigatório"),
});

export type InsertLead = z.infer<typeof insertLeadSchema>;
export type Lead = typeof leads.$inferSelect;

// Tabela de sessões de treinamento
export const sessions = pgTable("sessions", {
  id: serial("id").primaryKey(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  leadId: integer("lead_id").references(() => leads.id).notNull(), // Referência direta ao lead (aluno)
  trainerId: integer("trainer_id").references(() => trainers.id).notNull(),
  location: text("location").notNull(), // Endereço do treino
  value: integer("value").notNull(), // Valor em centavos (R$)
  service: text("service").notNull(), // Tipo do serviço
  isOneTime: boolean("is_one_time").default(false).notNull(), // Sessão avulsa
  weeklyFrequency: integer("weekly_frequency"), // Quantas vezes na semana (apenas se não for avulsa)
  weekDays: text("week_days").array(), // Dias da semana (apenas se não for avulsa)
  notes: text("notes"),
  status: text("status").default("agendado").notNull(), // agendado, concluído, cancelado, remarcado
  source: text("source").notNull(), // "Favale", "Pink" ou "FavalePink"
  // Campos para sessões recorrentes
  parentSessionId: integer("parent_session_id"), // ID da primeira sessão da série
  recurrenceGroupId: text("recurrence_group_id"), // UUID para agrupar toda a série
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertSessionSchema = createInsertSchema(sessions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const sessionBaseValidationSchema = insertSessionSchema.extend({
  startTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de início precisa ser uma data válida"
  }),
  endTime: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).refine(date => date instanceof Date && !isNaN(date.getTime()), {
    message: "Horário de término precisa ser uma data válida"
  }),
  leadId: z.number().int().positive("ID do aluno inválido"),
  trainerId: z.number().int().positive("ID do professor inválido"),
  location: z.string().min(1, "O local é obrigatório"),
  value: z.number().int().positive("O valor deve ser maior que zero"),
  service: z.string().min(1, "O serviço é obrigatório"),
  isOneTime: z.boolean().optional(),
  weeklyFrequency: z.number().int().positive("Frequência semanal deve ser um número positivo").optional(),
  weekDays: z.array(z.enum(["Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado", "Domingo"])).optional(),
  notes: z.string().optional(),
  status: z.enum(["agendado", "concluído", "cancelado", "remarcado"], {
    errorMap: () => ({ message: "Status deve ser 'agendado', 'concluído', 'cancelado' ou 'remarcado'" })
  }),
  source: z.enum(["Favale", "Pink", "FavalePink"], {
    errorMap: () => ({ message: "Origem deve ser 'Favale', 'Pink' ou 'FavalePink'" })
  }),
  parentSessionId: z.number().int().positive("ID da sessão pai inválido").optional(),
  recurrenceGroupId: z.string().optional(),
});

// Validação adicional para a criação de sessões
export const sessionValidationSchema = sessionBaseValidationSchema.refine(
  data => {
    // Verifica se a data de término é posterior à data de início
    const startTime = data.startTime instanceof Date ? data.startTime : new Date(data.startTime as string);
    const endTime = data.endTime instanceof Date ? data.endTime : new Date(data.endTime as string);
    return endTime > startTime;
  },
  {
    message: "O horário de término deve ser posterior ao horário de início",
    path: ["endTime"],
  }
);

export type InsertSession = z.infer<typeof insertSessionSchema>;
export type Session = typeof sessions.$inferSelect;

// Tabela de histórico de alterações em sessões
export const sessionHistory = pgTable("session_history", {
  id: serial("id").primaryKey(),
  sessionId: integer("session_id").references(() => sessions.id).notNull(),
  changedAt: timestamp("changed_at").defaultNow().notNull(),
  changeType: text("change_type").notNull(), // created, updated, cancelled, rescheduled
  userId: integer("user_id").references(() => users.id).notNull(), // Quem fez a alteração
  oldValue: jsonb("old_value"), // Valor anterior (para campos alterados)
  newValue: jsonb("new_value"), // Novo valor
});

export const insertSessionHistorySchema = createInsertSchema(sessionHistory).omit({
  id: true,
});

export type InsertSessionHistory = z.infer<typeof insertSessionHistorySchema>;
export type SessionHistory = typeof sessionHistory.$inferSelect;

// WhatsApp mensagens
export const whatsappMessages = pgTable("whatsapp_messages", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").references(() => leads.id).notNull(),
  direction: text("direction").notNull(), // "incoming" ou "outgoing"
  content: text("content").notNull(),
  status: text("status").notNull(), // "sent", "delivered", "read", "failed"
  timestamp: timestamp("timestamp").defaultNow().notNull(),
  mediaUrl: text("media_url"), // URL opcional para mídia (imagens, áudio, etc.)
  mediaType: text("media_type"), // Tipo de mídia (image, audio, video, document)
  messageId: text("message_id"), // ID da mensagem na API do WhatsApp
});

export const insertWhatsappMessageSchema = createInsertSchema(whatsappMessages).omit({
  id: true,
});

export const whatsappMessageValidationSchema = insertWhatsappMessageSchema.extend({
  leadId: z.number().int().positive("ID do lead inválido"),
  direction: z.enum(["incoming", "outgoing"], {
    errorMap: () => ({ message: "Direção deve ser 'incoming' ou 'outgoing'" })
  }),
  content: z.string().min(1, "O conteúdo da mensagem é obrigatório"),
  status: z.enum(["pending", "sent", "delivered", "read", "failed"], {
    errorMap: () => ({ message: "Status inválido" })
  }),
  mediaUrl: z.string().url("URL de mídia inválida").optional(),
  mediaType: z.enum(["image", "audio", "video", "document"], {
    errorMap: () => ({ message: "Tipo de mídia inválido" })
  }).optional(),
  messageId: z.string().optional(),
});

export type InsertWhatsappMessage = z.infer<typeof insertWhatsappMessageSchema>;
export type WhatsappMessage = typeof whatsappMessages.$inferSelect;

// Tabela de tarefas
export const tasks = pgTable("tasks", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  assignedById: integer("assigned_by_id").references(() => users.id).notNull(),
  assignedToId: integer("assigned_to_id").references(() => users.id).notNull(),
  dueDate: timestamp("due_date"),
  priority: text("priority").default("medium").notNull(), // low, medium, high
  status: text("status").default("pending").notNull(), // pending, in_progress, completed, cancelled
  // relatedLeadId is kept for backward compatibility but will be phased out
  // Tasks are now assigned to system users only
  relatedLeadId: integer("related_lead_id").references(() => leads.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskValidationSchema = insertTaskSchema.extend({
  title: z.string().min(1, "O título é obrigatório"),
  description: z.string().optional(),
  assignedById: z.number().int().positive("ID do usuário que atribuiu a tarefa inválido"),
  assignedToId: z.number().int().positive("ID do usuário atribuído inválido"),
  dueDate: z.preprocess((arg) => {
    if (typeof arg === "string" || arg instanceof Date) return arg;
    // If arg is null or undefined, let it pass to be handled by .optional()
    if (arg === null || arg === undefined) return arg;
    // For other invalid types, return undefined to trigger validation error if not optional
    return undefined;
  }, z.union([
    z.string().transform(val => new Date(val)),
    z.date()
  ])).optional().refine(date => date ? (date instanceof Date && !isNaN(date.getTime())) : true, {
    message: "Data de vencimento precisa ser uma data válida ou estar vazia"
  }),
  priority: z.enum(["low", "medium", "high"], {
    errorMap: () => ({ message: "Prioridade deve ser 'low', 'medium' ou 'high'" })
  }),
  status: z.enum(["backlog", "pending", "in_progress", "completed", "cancelled"], {
    errorMap: () => ({ message: "Status deve ser 'backlog', 'pending', 'in_progress', 'completed' ou 'cancelled'" })
  }),
  relatedLeadId: z.number().int().positive("ID do lead inválido").optional(),
});

export type InsertTask = z.infer<typeof insertTaskSchema>;
export type Task = typeof tasks.$inferSelect;

// Tabela de comentários em tarefas
export const taskComments = pgTable("task_comments", {
  id: serial("id").primaryKey(),
  taskId: integer("task_id").references(() => tasks.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertTaskCommentSchema = createInsertSchema(taskComments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const taskCommentValidationSchema = insertTaskCommentSchema.extend({
  taskId: z.number().int().positive("ID da tarefa inválido"),
  userId: z.number().int().positive("ID do usuário inválido"),
  content: z.string().min(1, "O conteúdo é obrigatório"),
});

export type InsertTaskComment = z.infer<typeof insertTaskCommentSchema>;
export type TaskComment = typeof taskComments.$inferSelect;

// Tabela de configurações do WhatsApp/Evolution API
export const whatsappSettings = pgTable("whatsapp_settings", {
  id: serial("id").primaryKey(),
  apiUrl: text("api_url").notNull(),
  apiToken: text("api_token").notNull(),
  apiInstance: text("api_instance").notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertWhatsappSettingsSchema = createInsertSchema(whatsappSettings).omit({
  id: true,
  updatedAt: true,
});

export type InsertWhatsappSettings = z.infer<typeof insertWhatsappSettingsSchema>;
export type WhatsappSettings = typeof whatsappSettings.$inferSelect;
